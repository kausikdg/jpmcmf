'use strict';

const spawn = require('child_process').spawn;
const Queue = require('promise-queue');
const S3270Screen = require('./S3270Screen');

const queue = new Queue(1, Infinity);

const S3270Process = module.exports = function(address, options) {
    this.process = spawn('ws3270', [ address ], {
        stdio: [ 'pipe', 'pipe', 'pipe']
    });

    this.in = this.process.stdin;
    
    this.out = this.process.stdout;
    this.out.setEncoding('utf8');
    
    this.err = this.process.stderr;
};

S3270Process.prototype.sendCommand = function(command) {
    const stdin = this.in;
    const stdout = this.out;

    return queue.add(function() {
        return new Promise(function(resolve, reject) {
            var buffer = "";

            var dataListener = function(chunk) {
                //console.log(`Received ${chunk.length} bytes of data.`);
                buffer += chunk;
                if (/^ok$/m.test(buffer)) {
                    cleanup();
                    return resolve(buffer);
                }

                if (/^error$/m.test(buffer)) {
                    cleanup();
                    return reject(buffer);
                }
            };

            var closeListener = function() {
                console.log('Stream closed');
                cleanup();
                reject();
            };

            var cleanup = function() {
                stdout.removeListener('data', dataListener);
                stdout.removeListener('close', closeListener);
            };

            // set up listeners
            stdout.on('data', dataListener);
            stdout.on('close', closeListener);

            // write to the process
            console.log("Send command: " + command);
            stdin.write(command + "\n");
        });
    });
};

S3270Process.prototype.status = function() {
    return this.sendCommand("").then(function(data) {
        // data format:
        // U F U C(fandezhi.efglobe.com) I 4 24 80 20 21 0x0 -

        var split = data.split(' ');
        var out = {};

        // 1. keyboard state
        switch (split[0]) {
            case 'U':
                out.keyboardState = STATUS.KEYBOARD_UNLOCKED;
                break;
            case 'L':
                out.keyboardState = STATUS.KEYBOARD_LOCKED;
                break;
            case 'E':
                out.keyboardState = STATUS.KEYBOARD_ERROR;
                break;
        };

        // 2. screen formatting
        switch (split[1]) {
            case 'F':
                out.screenFormatting = STATUS.SCREEN_FORMATTED;
                break;
            case 'U':
                out.screenFormatting = STATUS.SCREEN_UNFORMATTED;
                break;
        };

        // 3. field protection
        out.fieldProtected = (split[2] === 'P');

        // 4. connection state
        out.connected = (split[3].startsWith('C'));
        if (out.connected) {
            out.connectedHost = split[3].substring(2, split[3].length - 1);
        }

        // 5. emulator mode
        switch (split[4]) {
            case 'I':
                out.emulatorMode = STATUS.EMULATOR_3270;
                break;
            case 'L':
                out.emulatorMode = STATUS.EMULATOR_NVT_LINE;
                break;
            case 'C':
                out.emulatorMode = STATUS.EMULATOR_NVT_CHAR;
                break;
            case 'P':
                out.emulatorMode = STATUS.EMULATOR_UNNEGOTIATED;
                break;
            case 'N':
                out.emulatorMode = STATUS.EMULATOR_NOT_CONNECTED;
                break;
        }

        // 6. model number
        out.modelNumber = parseInt(split[5]);

        // 7. rows
        out.rows = parseInt(split[6]);

        // 8. columns
        out.columns = parseInt(split[7]);

        // 9. cursor rows
        out.cursorRow = parseInt(split[8]);

        // 10. cursor column
        out.cursorColumn = parseInt(split[9]);

        // 12. last command time
        if (split[11] !== '-') {
            out.lastCommandTime = parseFloat(split[11]);
        }

        return out;
    });
};

S3270Process.prototype.sendKeys = function(str) {
    var promises = [];

    for (var i = 0, len = str.length; i < len; i++) {
        promises.push(this.sendCommand("key (U+" + str.charCodeAt(i).toString(16) + ")"));
    }

    return Promise.all(promises);
};

S3270Process.prototype.readScreen = function() {
    return this.sendCommand("readbuffer(ascii)")
        .then((asciiBuffer) => { return new S3270Screen(asciiBuffer); })
};

S3270Process.prototype.applyScreen = function(screen) {
    var promises = [];

    for (let field of screen.fields) {
        if (field.hasNewValue()) {
            let changePromise = this.sendCommand("moveCursor(" + field.lineNum + "," + (field.startIdx + 1) + ")")
                                    .then(this.sendKeys(field.getValue()));
            promises.push(changePromise);
        }
    }

    Promise.all(promises);
}

const STATUS = exports.STATUS = {
    KEYBOARD_UNLOCKED: "unlocked",
    KEYBOARD_LOCKED: "locked",
    KEYBOARD_ERROR: "error",
    SCREEN_FORMATTED: "formatted",
    SCREEN_UNFORMATTED: "unformatted",
    EMULATOR_3270: "3270",
    EMULATOR_NVT_LINE: "nvt_line",
    EMULATOR_NVT_CHAR: "nvt_char",
    EMULATOR_UNNEGOTIATED: "unnegotiated",
    EMULATOR_NOT_CONNECTED: "not_connected"
}