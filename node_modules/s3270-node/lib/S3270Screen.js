'use strict';

const S3270Field = require('./S3270Field');

const S3270Screen = module.exports = function(asciiBuf) {
    this.asciiBuf = asciiBuf;
    this.fields = parse(this.asciiBuf);

    function parse(asciiBuf) {
        const fields = [];
        const lines = asciiBuf.split('\n');
        
        for (var lineNum = 0; lineNum < lines.length; lineNum++) {
            if (lines[lineNum].startsWith("data:")) {
                processLine(lines[lineNum], lineNum, fields);
            }
        }

        return fields;
    }

    function processLine(line, lineNum, fields) {
        const chars = line.split(" ");
        let curIdx = 0;
        let curField = new S3270Field(lineNum, 0);

        for (var i = 1; i < chars.length; i++) {
            // handle an ascii character by:
            // - incrementing the index
            // - adding it to the value of the current field (if any)
            // - updating the end of the current field to the index
            if (chars[i].length == 2) {
                curIdx++;

                if (curField) {
                    curField.endIdx = curIdx;
                    
                    if (chars[i] !== '00') {
                        curField.val += String.fromCharCode(parseInt(chars[i], 16));
                    }
                }
            }

            if (chars[i].startsWith("SF")) {
                // if we are in the middle of processing a field,
                // end processing and push it
                if (curField) {
                    addField(curField, fields);
                }

                // start a new field
                curField = new S3270Field(lineNum, curIdx);

                // increment counter since SF does take up a
                // space in the input buffer (it appears as)
                // a blank on the screen
                curIdx++;

                // process attributes
                processFieldAttributes(chars[i], curField);
            }
        }

        // is there a last field?
        if (curField) {
            addField(curField, fields);
        }
    }

    function addField(field, fields) {
        // ignore blank fields
        if (field.startIdx == field.endIdx) {
            return;
        }

        field.idx = (fields.push(field) - 1);
    }

    function processFieldAttributes(sf, field) {
        const attrs = sf.substring(3, sf.length - 1).split(",");
        for (let attr of attrs) {
            const splitAttr = attr.split("=");
            if (splitAttr[0] === "c0") {
                let value = parseInt(splitAttr[1], 16);

                field.protected = (value & FIELD_ATTR_MASK.PROTECTED) == FIELD_ATTR_MASK.PROTECTED;
                field.numeric = (value & FIELD_ATTR_MASK.NUMERIC) == FIELD_ATTR_MASK.NUMERIC;
                field.modified = (value & FIELD_ATTR_MASK.MODIFIED) == FIELD_ATTR_MASK.MODIFIED;
                field.hidden = (value & FIELD_ATTR_MASK.NON_DISPLAY) == FIELD_ATTR_MASK.NON_DISPLAY;

                if (field.hidden) {
                    field.intensified = false;
                    field.detectable = false;
                } else {
                    field.intensified = (value && FIELD_ATTR_MASK.INTENSIFIED) == FIELD_ATTR_MASK.INTENSIFIED;
                    field.detectable = (value && FIELD_ATTR_MASK.DETECTABLE) == FIELD_ATTR_MASK.DETECTABLE;
                }
            }
        }
    }
}

S3270Screen.prototype.ascii = function() {
    let out = "";
    const lines = this.asciiBuf.split('\n');
    
    for (let line of lines) {
        if (line.startsWith("data:")) {
            const chars = line.split(" ");
            for (let c of chars) {
                if (c.length == 2) {
                    if (c == '00') {
                        out += " ";
                    } else {
                        out += String.fromCharCode(parseInt(c, 16));
                    }
                } else if (c.startsWith("SF")) {
                    out += " ";
                }
            }
            out += "\n";
        }
    }  

    return out;
}

S3270Screen.prototype.printFields = function() {
    return JSON.stringify({ fields: this.fields }, null , 2);
}

// find a field by index
S3270Screen.prototype.fieldByIndex = function(idx) {
    return this.fields[idx];
}

// find all fields by line number
S3270Screen.prototype.fieldsByLine = function(lineNum) {
    let out = [];

    for (let field of this.fields) {
        if (field.lineNum == lineNum) {
            out.push(field);
        }
    }

    return out;
}

// find the first field with the given text.
// Can be a string or regex pattern
S3270Screen.prototype.firstFieldWithText = function(text, acceptFunc) {
    for (let field of this.fields) {
        if (acceptFunc && !acceptFunc.call(this, field)) {
            continue;
        }

        if ((text instanceof RegExp && text.test(field.getValue())) ||
            (text === field.getValue()))
        {
            return field;   
        }
    }
    
    return null;
}

// find the next editable field after a field
// with the given text
S3270Screen.prototype.editableFieldAfterText = function(text, acceptFunc) {
    let textField = this.firstFieldWithText(text, acceptFunc);
    if (!textField) {
        return null;
    }

    for (var i = textField.idx + 1; i < this.fields.length; i++) {
        let nextField = this.fields[i];
        if (typeof nextField.protected !== "undefined" && 
            nextField.protected == false) 
        {
            return nextField;
        }
    }

    return null;
}

const FIELD_ATTR_MASK = {
    PROTECTED: 0x20,
    NUMERIC: 0x10,
    DETECTABLE: 0x04,
    INTENSIFIED: 0x08,
    NON_DISPLAY: 0x0C,
    MODIFIED: 0x01
}